simulated annealing
    like a random walk
    basic idea
        instead of picking the best move, pick one randomly
        say change in objective function is delta
        if delta is positive (uphill) then move to that state
        otherwise
            move to this state with probability proportional to delta
            thus: worse moves (very large negative delta) are executed less
        delta is modified by temperature T

temperature T
    current = next with prob e^(delta E / T)
        delta E is gaurranteed to be negative
        high T: prob of locally bad move is higher
        low T: prob of locally bad move is lower
    typically, T is decreased as the alg runs longer
    i.e. there is a temperature schedule

applications
    traveling salesman
    graph partitioning
    graph coloring
    scheduling
    facility layout

local beam search
    kepping only one node in memory is an extreme reaction to memory problems
    instead, keep track of k states (hill climbing with k states)
        initially: k randomly selected states
        next: determine all successors of k states
        if any of successors is goal
            then finished
        else
            select k best from successors and repeat
    not the same as k random-start searches in parrallel
    searches that find good states recruit other searches to join them

genetic algorithms
    twist on local search
        successor is generated by combining two parent states

constraint satisfaction problems (CSPs)
    state is defined by vars X[i], with values from domain D[i]
    goal test is a set of constraints
        specifies allowable combos of values for subsets of variables
    simple example of a formal representation language
    allows general-purpose algs with more power than standard search algs

constraint satisfaction
    example: map coloring
        variables
            countries (A, B, C, etc.)
        values
            colors (red, green, yellow)
        constraints
            adjacent countries are not the same color
            a != b, a != d, d != e, etc.
    example: sudoku
        variables
            X[1] -> X[81]
        domain
            {1, 2, ..., 9}
        constraints
            one for each row
            one for each column
            one for each block
