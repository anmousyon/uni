kernel mode
	can execute privileged operations directly

user mode
	use system calls to execute privileged operations

system calls
	fork
		creates a child process
		child inherits all the code and global/local data on hand
		use pid to determine if its child or parent
			pid is 0 if child / >1 if parent
	exec
		the code and data in child is overwritten with new code

copy on write
	a set of pointers points to parent data
	data only copied to parent if it needs to be changed

context switch
	switching from one process (context) to another

process creation is heavy while thread creation is light

threads
	most modern apps are multithreaded
	run within an application
	threads created in the same process share the same address space
	each thread has a small amount fo space for itself
	threads are more efficient when switching between tasks
	simplifies code / increaases efficiency
	kernals are generally multithreaded

benefits
	responsiveness
		allow continued execution if part of process is blocked
		very useful for UIs
	resource sharing
		easier than shared memory or message passing
	economy
		cheaper than process creation
		thread switching lower overhead than context switching
	scalability
		can take advantage of multiprocessor architecture

multicore programming
	divide activities
	balance
	data splitting
	data dependency
	testing and debugging
	parallelism
		implies a system can perform more then one task simultaneously
	concurrency
		supports more then one task making progress
		single processor/core, scheduler providing concurrency
	code, data, and files are shared between threads
	each thread has its own registers and stack

amdahls law
	IDs performance gains from adding additional cores
		to an app that has both serial and parallel components
	S -> serial portion
	N -> processing cores
	speedup <= 1/(S+((1-S)/N)
	As N approaches infinity, speedup approaches 1/S
	Serial portion of an app has disproportionate effect on performance
	speedup increases in a sublinear fashion (diminishing returns)

user threads
	management done by user-level threads library

many-to-one
	many user-level threads mapped to single kernel thread
	one thread blocking causes all to block
	multiple threads may not run in parallel on multicore system
		because only one may be in kernal at a time

one-to-one
	each user level thread maps to kernel thread
	creating a user-level thread creates a kernel thread
	more concurrency than many-to-one
	# of threads per process sometimes restricted duo to overhead

signal handling
	notify a process that a prticular event has occured
	signal handler
		user to process signals
		signal is generated by particular event
		signal is delivered to a process
		signal is handled by one of two signal handlers
			default
			user-defined
	svery sgnal has default handler
		kernel runs this when hadling singal
		user-defined can override default
		for single-threaded, signal delivered to process

thread cancellation
	invoking thread cancel only requests calncel
		actual cancel depends on thread state
	if thread cancel disabled
		cancel remains pending until thread enables it
	default type is deferred
