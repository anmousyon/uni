## CHAPTER * ##
address spaces
    logical address
        generated by CPU
        also referred to as virtual address
    physical address
        address seen by the memory unit

paging
    frames
        fixed-size blocks of physical memory (512 bytes - 16 kb)
    pages
        blocks of same size of logical memory
    page table
        translates logical to physical addresses
    page number (p)
        used as an index into a page table
    page offset (d)
        combined with base address to define the physical memory address
    bit diagram
        page number (size m-n) | page offest (size n)
        for fiven logical address space 2^m and page size 2^n

page table
    table kept in main memory
    page-table base register (PTBR)
        points to the page table
    page-table length register (PTLR)
        indicates size of page table
    requires two instructions for every data/instruction access
        one for page table
        one for data/instruction
        can be solved with translation look-aside buffers (TLBs)
    address-space identifiers (ASIDs)
        stored by TLBs in each TLB entry
        uniquely IDs each process
            to provide address-space protection for that process

effective access time (EAT)
    hit ratio = alpha
    asociatve lookup time = epsilon
    EAT = (1+epsilon)*alpha + (2+epsilon)*(1-alpha) = 2 + epsilon - alpha

memory protection
    implemented by associating protection bit with each frame
    to indicate if read-only or read-write access is allowed
    valid-invalid
        bit attached to each entry in page table
        valid
            page is in the logical address space (legal)
        invalid
            page is not in logical address page (illegal)
        or use page-table length register (PTLR)
    any violations result in trap to the kernel

page table structure
    can get huge using straight forward methods
    better methods
        hierarchical paging
            break up logical space into multiple page tables
            simple version is two-level page table
            page the page table
        hashed tables
            virtual page number is hashed into page table
                page table contains a chain of elements hashing to same location
            each element contains
                virtual page number
                value of mapped page frame
                pointer to next element
            virtual page numbers are compared in this chain for match
                on match, corresponding physical frame is extracted
            clustered page tables
                similar to hashed but each entry refers to several pages (such as 16)
                useful for sparse address spaces
        inverted tabes

## CHAPTER 9 ##
handling a page fault
    broken reference
    trap to the os
    page in on backing store
    bring in missing page
    reset page table
    restart function

basic page replacement
    find location of desired page on disk
    find a free frame
        if there inst one, use page replacement algorithm to select victim
        write victim fram to disk if dirty
    bring desired page into (newly) free frame
        update the page and frame tables
    continue process by restarting the instruction that caused the trap

frame-allocation algorithm determines
    how many frames to give each process
    which frames to replace

page-replacement algorithm
    want lowest page-fault rate on both first & re-access
    optimal
        LRU

LRU
    replace page that has not been used in most amount of time
    associate time of last use with each page

LRU approximation
    reference bit implementation